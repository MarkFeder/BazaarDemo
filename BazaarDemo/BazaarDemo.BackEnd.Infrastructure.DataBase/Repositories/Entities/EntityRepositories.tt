<#@ template language="C#" debug="false" hostspecific="true"#>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.11.0" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.Shell" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="System.Diagnostics" #>
<#@ include file="EF.Utility.CS.ttinclude"#>
<#@ output extension="/"#>
<#
//===================================================================================================
// BEGIN OF EDITABLE AREA. CHANGES OUTSIDE HERE ARE WITHOUT SUPPORT FROM EVERIS ↑↑
//===================================================================================================
// Uncoment the following line and change the debug attribute in the template tag to allow debugging
//System.Diagnostics.Debugger.Launch();

//Suffix of created file:
string filenameSuffix = "Repository.cs";
//Namespace where find classes:
string rootNamespace = "BazaarDemo.BackEnd.Domain.Entities";
// include additional using statements here
List<string> usingList = new List<string>(){
			rootNamespace,
            "BazaarDemo.BackEnd.Domain.Contracts.EntityRepositories",
            "EverNext.Domain.Contracts.Repositories",
            "EverNext.Infrastructure.EntityFramework.DbContext",
			"System.CodeDom.Compiler",
            "EverNext.Domain.Contracts.Model"
};
//===================================================================================================
// END OF EDITABLE AREA. CHANGES OUTSIDE HERE ARE WITHOUT SUPPORT FROM EVERIS ↓↓
//===================================================================================================

CodeGenerationTools code = new CodeGenerationTools(this);
MetadataLoader loader = new MetadataLoader(this);
CodeRegion region = new CodeRegion(this, 1);
MetadataTools ef = new MetadataTools(this);

string namespaceName =  code.VsNamespaceSuggestion();
EntityFrameworkTemplateFileManager fileManager = EntityFrameworkTemplateFileManager.Create(this);

// Write out support code to primary template output file
WriteHeader(fileManager, usingList.ToArray());
BeginNamespace(namespaceName, code);
EndNamespace(namespaceName);

// Emit Entity Types

foreach (CodeClass classes in FindClasses(rootNamespace, "", "BaseEntity").Where(c=>c.ImplementedInterfaces.OfType<CodeInterface>()
                                                                                      .Any(d=>d.Name.Equals("IAggregateRoot"))))
{
	string capitalizedClassName = CapitalizeFirstLetter(classes.Name);
    fileManager.StartNewFile(classes.Name + filenameSuffix);
    BeginNamespace(namespaceName, code);

#>
<#="public"#> <#=code.SpaceAfter(classes.IsAbstract ? "abstract" : string.Empty)#>partial class <#= capitalizedClassName #>Repository : LinqRepository<<#=classes.FullName#>>,I<#=classes.Name#>Repository
{
    public <#= capitalizedClassName #>Repository (System.Data.Entity.DbContext context) : base(context)
    {

    }
}
<#
    EndNamespace(namespaceName);
}

fileManager.Process();

#>
<#+
void WriteHeader(EntityFrameworkTemplateFileManager fileManager, params string[] extraUsings)
{
    fileManager.StartHeader();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template (EntityRepositories.tt).
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Linq;
<#=String.Join(String.Empty, extraUsings.Select(u => "using " + u + ";" + Environment.NewLine).ToArray())#>
<#+
    fileManager.EndBlock();
}

void BeginNamespace(string namespaceName, CodeGenerationTools code)
{
    CodeRegion region = new CodeRegion(this);
    if (!String.IsNullOrEmpty(namespaceName))
    {
#>
namespace <#=code.EscapeNamespace(namespaceName)#>
{
<#+
        PushIndent(CodeRegion.GetIndent(1));
    }
}

void EndNamespace(string namespaceName)
{
    if (!String.IsNullOrEmpty(namespaceName))
    {
        PopIndent();
#>
}
<#+
    }
}

bool VerifyTypesAreCaseInsensitiveUnique(EdmItemCollection itemCollection)
{
    Dictionary<string, bool> alreadySeen = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
    foreach(StructuralType type in itemCollection.GetItems<StructuralType>())
    {
        if (!(type is EntityType || type is ComplexType))
        {
            continue;
        }

        if (alreadySeen.ContainsKey(type.FullName))
        {
            Error(String.Format(CultureInfo.CurrentCulture, "This template does not support types that differ only by case, the types {0} are not supported", type.FullName));
            return false;
        }
        else
        {
            alreadySeen.Add(type.FullName, true);
        }

    }

    return true;
}

    private System.Collections.Generic.List<CodeClass> FindClasses(string nameSpace, string className, string baseClassName)
    {
        System.Collections.Generic.List<CodeClass> result = new System.Collections.Generic.List<CodeClass>();
        FindClasses(GetProject().CodeModel.CodeElements, className, baseClassName, nameSpace, result, false);
        return result;

    }

    private void FindClasses(CodeElements elements, string className, string baseClassName, string searchNamespace, List<CodeClass> result, bool isNamespaceOk)
    {
        if (elements == null) return;
        foreach (CodeElement element in elements)
        {
            if (element is EnvDTE.CodeNamespace)
            {
                EnvDTE.CodeNamespace ns = element as EnvDTE.CodeNamespace;
                if (ns != null)
                {
                    if (ns.FullName.StartsWith(searchNamespace))
                        FindClasses(ns.Members, className, baseClassName, searchNamespace, result, true);
                    else
                        FindClasses(ns.Members, className, baseClassName, searchNamespace, result, false);
                }
            }
            else if (element is CodeClass && isNamespaceOk)
            {
                CodeClass c = element as CodeClass;
                if (c != null)
                {
                    if (c.FullName.Contains(className) && (baseClassName == null || (HasIt(c.Bases, baseClassName) && c.Name != baseClassName)))
                        result.Add(c);

                    FindClasses(c.Members, className, baseClassName, searchNamespace, result, true);
                }

            }
        }
    }

    private bool HasIt(CodeElements elements, string name)
    {
        foreach (CodeElement element in elements)
        {
            CodeClass c = element as CodeClass;
            if (c != null && c.Bases != null)
            {
                if (HasIt(c.Bases, name))
                {
                    return true;
                }
            }

            if (element.Name == name)
                return true;
        }
        return false;
    }

	private List<CodeClass> GetPartialClasses(CodeClass2 c)
    {
        System.Collections.Generic.List<CodeClass> result = new System.Collections.Generic.List<CodeClass>();
        foreach (CodeClass2 p in c.PartialClasses)
        {
            result.Add(p);
        }

        return result;
    }

    private Project GetProject()
    {
        IServiceProvider serviceProvider = (IServiceProvider)this.Host;
        DTE dte = serviceProvider.GetService(typeof(DTE)) as DTE; 
        // Get DTE
        //var dte = (DTE)TransformationContext.Current.GetService(typeof(DTE));

        // Get ProjectItem representing the template file
        ProjectItem projectItem = dte.Solution.FindProjectItem(this.Host.TemplateFile);

        // Get the Project of the template file
        Project project = projectItem.ContainingProject;

        return project;
    }

    private string GetDefaultNamespace()
    {
        IServiceProvider serviceProvider = (IServiceProvider)this.Host;
        DTE dte = serviceProvider.GetService(typeof(DTE)) as DTE; 
        // Get DTE
        //var dte = (DTE)TransformationContext.Current.GetService(typeof(DTE));

        // Get ProjectItem representing the template file
        ProjectItem projectItem = dte.Solution.FindProjectItem(this.Host.TemplateFile);

        // Get the Project of the template file
        Project project = projectItem.ContainingProject;

        var vsSolution = (IVsSolution)serviceProvider.GetService(typeof(SVsSolution));
        IVsHierarchy vsHierarchy;
        ErrorHandler.ThrowOnFailure(vsSolution.GetProjectOfUniqueName(project.FullName, out vsHierarchy));
        uint projectItemId;
        ErrorHandler.ThrowOnFailure(vsHierarchy.ParseCanonicalName(projectItem.FileNames[1], out projectItemId));
        object defaultNamespace;
        ErrorHandler.ThrowOnFailure(vsHierarchy.GetProperty(projectItemId, (int)VsHierarchyPropID.DefaultNamespace, out defaultNamespace));
        return ((string)defaultNamespace);
    }

	private ProjectItem GetProjectItemFromTemplate()
{
    IServiceProvider serviceProvider = (IServiceProvider)this.Host;
    DTE dte = serviceProvider.GetService(typeof(DTE)) as DTE; 

    // Get ProjectItem representing the template file
    ProjectItem projectItem = dte.Solution.FindProjectItem(this.Host.TemplateFile);
        
    return projectItem;
}

private string CapitalizeFirstLetter(string s)
{
    if (String.IsNullOrEmpty(s))
        return s;
    if (s.Length == 1)
        return s.ToUpper();
    return s.Remove(1).ToUpper() + s.Substring(1);
}
#>